// GA contract
//
// Main/master account can change setting
//
// Temporary accounts can authenticate

@compiler >= 5

main contract GAMainWTemporary =
  datatype trustee
    = Plain
    | TimeBound(int)
    | NBound(int)

  record meta_tx_protection =
    { max_fee : int,
      max_gasprice : int }

  record state =
    { master : address,
      trustees : map(address, trustee),
      fee_protection : option(meta_tx_protection),
      nonce : int}

  entrypoint init(master : address) =
    require(master != Call.caller, "Master not allowed to be the account itself")
    { master = master,
      trustees = {},
      fee_protection = Some({max_fee = 2_000_000_000_000_000, max_gasprice = 1_000_000_000_000}),
      nonce = 1}

  stateful entrypoint authorize(n : int, signer : address, sig : signature) : bool =
    require(n >= state.nonce, "Nonce too low")
    require(n =< state.nonce, "Nonce too high")
    require(fee_ok(), "Fee or gasprice too high")
    require(allowed_signer(signer), "Not allowed to sign")
    put(state{ nonce = n + 1 })

    switch(Auth.tx_hash)
      None => abort("Not in Auth context")
      Some(tx_hash) =>
        Crypto.verify_sig(to_sign(tx_hash, n), signer, sig)

  stateful entrypoint add_trustee(signer : address, trustee : trustee) =
    require(Call.caller == state.master, "Only for master")
    put(state{ trustees[signer] = trustee })

  stateful entrypoint remove_trustee(signer : address) =
    require(Call.caller == state.master, "Only for master")
    put(state{ trustees = Map.delete(signer, state.trustees) })

  entrypoint get_signer(signer) : option(trustee) =
    Map.lookup(signer, state.trustees)

  entrypoint get_nonce() : int =
    state.nonce

  entrypoint get_trustees() : list(address * trustee) =
    Map.to_list(state.trustees)

  entrypoint get_state(): state =
    state

  stateful entrypoint set_fee_protection(fee_protection : option(meta_tx_protection)) =
    require(Call.caller == state.master, "Only for master")
    put(state{ fee_protection = fee_protection })

  stateful function allowed_signer(signer : address) =
    if (signer == state.master)
      true
    else
      switch(Map.lookup(signer, state.trustees))
        Some(Plain) =>
          true
        Some(TimeBound(height)) =>
          if(height < Chain.block_height)
            put(state{ trustees = Map.delete(signer, state.trustees) })
            false
          else
            true
        Some(NBound(n)) | n > 1 =>
          put(state{ trustees[signer] = NBound(n - 1) })
          true
        Some(NBound(_)) =>
          put(state{ trustees = Map.delete(signer, state.trustees) })
          true
        _ =>
          false

  // Static function, but useful with dry-run to create signing material
  entrypoint to_sign(tx_hash : hash, nonce : int) : hash =
    Crypto.blake2b((tx_hash, nonce))

  function fee_ok() =
    switch(state.fee_protection)
      None =>
        true
      Some(fp) =>
        fp.max_fee >= Call.fee && fp.max_gasprice >= Call.gas_price
